---
title: "JedR: Using Lubridate to work with dates"
author: ""
output: html_document
---

Hello, young Padawan! In this tutorial we'll look at how the `Lubridate` package can make life easier when dealing with dates in R. In doing so, we'll examine a dataset, scraped from [tvmaze.com](https://www.tvmaze.com/shows/117/star-wars-rebels/episodes), with information about the *Star Wars Rebels* series.

## Load packages

```{r setup, warning=FALSE, message=FALSE}
library(lubridate) # to work with dates and time
library(tidyverse) # to clean and wrangle the data
library(janitor) # to clean column names
library(learnr)
library(gradethis)
```

## Import data

```{r import}
rebels_raw <- read_csv("starwarsrebels.csv") # import data
rebels_raw |> glimpse() # see what the data looks like
```

This dataset has information about the *Star Wars Rebels* series. For each of the show's 69 episodes, we have it's episode number, air date, title, and season.

Note that some of the column names has spaces in them, which can make life harder. To fix it, let's use the `clean_names()` function from the `Janitor` package:

```{r}
rebels <- rebels_raw |> clean_names() # clean the names
rebels |> glimpse() # glimpse the "rebels" object
```

Now, the column names are easier to work with.

## Parsing dates: Making sure that dates are recognized as such in R

Notice that when we used the `glimpse()` above, we also got info about the type of each column. The episode number and season are read as *dbl* ("doubles, which is a number"), whereas the episode title and air date are read as *chr* ("characters").

To work effectively with dates, we need R to recognize when we're reading with dates. Do fix this, we can use `lubridate`'s [parse date functions](https://rawgit.com/rstudio/cheatsheets/main/lubridate.pdf). In this particular dataset, the dates are written in the *dmy* (date-month-year) format. (If you look in the `glimpse()` output above, you'll see that the first observation, for example, was: "13-Oct-14"). Let's use `lubridate`'s `dmy()` function to create a new version of the dataset, called *rebels_fix*, which has a new column called *air_date_fixed*:

```{r}
rebels |> 
  mutate(air_date_fixed = dmy(original_air_date)) |> 
  glimpse()
```

Notice that, in the chunk above, we're just looking at the output to see that this worked as intented. See that the `air_date_fixed` column is being read as a `date` whereas the `original_air_date` column was read as a `character`? Also, we're not saving it into a new object using the `<-` operator. Let's use the `<-` operator operator to save our work in a new object, called `rebels_cl`, without the `original_air_date` column, which we're not going to need:

```{r}
rebels_cl <- rebels |> 
  mutate(air_date_fixed = dmy(original_air_date)) |> 
  select(-original_air_date)

rebels_cl |> glimpse()
```

Two key things to notice here:

* `air_date_fixed` has the format `date`.
* In `air_date_fixed`, the year is written first, followed by the month and then the day. That's just what the date format looks like in R.

In this example, `lubridate`'s `dmy()` function came in handy. Here are some other functions we might've used if the dates had been formatted differently:

```{r}
### when using the mdy function, R knows that the first value is month, followed by day, followed by year
mdy("May 15, 1988")

### here, the ymd function makes it clear that the first value is year, followed by month, followed by day
ymd("1988-May-15")
```

You can find more examples and tips [in this cheatsheet](https://rawgit.com/rstudio/cheatsheets/main/lubridate.pdf).

### Another way of parsing dates

Base R also has a function to parse dates, called `as.Date()`, which you can read more about [here](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/as.Date). 

## Working with dates

Let's now make use of our newly created `air_date_fixed` column to understand the data.

### Which episodes were oldest or newest?

We can use the `arrange()` function to sort data frames based on dates.

#### The oldest episodes

```{r}
rebels_cl |> 
  arrange(air_date_fixed)
```

#### The newest episodes

```{r}
rebels_cl |> 
  arrange(desc(air_date_fixed)) # add "desc" to sort in descending order
```

### Only view episodes that aired before or after a given date

We can use the `filter()` function to only view episodes that aired before or after a given date:

#### Episodes aired in 2018 (the last year available)

```{r}
rebels_cl |> 
  filter(air_date_fixed >= "2018-01-01") #Notice that the date is written in quotes!
```

#### Episodes that aired in February 2016

```{r}
rebels_cl |> 
  filter(air_date_fixed >= "2016-02-01" & air_date_fixed < "2016-03-01")
```

### Which month had the most episodes (throughout the entire period)?

To answer this question, we can use `Lubridate`'s `month()` function, which allows us to focus only on months (while ignoring years). It works like this:

```{r month}
rebels_cl <- rebels_cl |> 
  mutate(month = month(air_date_fixed))

rebels_cl |> glimpse()
```

Notice that we're creating an object called `rebels_cl`, a name that we had already used? When doing so, only the new version of the object will be saved. It's OK in this case because we're confident that we won't need the version of the dataset without the `month` column. However, in general, you should always think carefully before "writing over" an existing object as we're doing here.

It's worth keeping in mind that "month" is now the name of a column (which we just created) *and* the name of a function from the `lubridate` package. That can be a bit confusing and it's generally best to avoid creating object with the same names as functions. 

Also, see how the newly created `month` column only has information about which month the episodes aired in, in this case "10" (October) for the first three observations and "11" (November) for the next four observations. If we wanted the names of the months, we can use the `label = TRUE` argument within the month function. Like this:

```{r month_label}
rebels_cl <- rebels_cl |> 
  mutate(month = month(air_date_fixed, label = TRUE))

rebels_cl |> glimpse()
```

Notice that the type for *month* is *"ord"*? This means that the column is written as an "ordered factor", which simply means (in this case) that although it looks like text, it would be ordered by time, not alphabetically. In other words, we can sort by the month column, if we want to do so:

```{r sort_month}
rebels_cl |> 
  select(episode_title, month) |> 
  arrange(month)
```

Going back to our question about which month had the most episodes

```{r}
rebels_cl |> 
  group_by(month) |> 
  count(name = "number_of_episodes") |> 
  arrange(desc(number_of_episodes) )
```

It looks like there were lot's of new episodes in October, November, February, and March. 

### Which year had the most episodes?

To get information about specific years, we can use the `year()` function, which is quite similar:

```{r year}
rebels_cl <- rebels_cl |> 
  mutate(year = year(air_date_fixed))

rebels_cl |> 
  group_by(year) |> 
  count(name = "number_of_episodes") |> 
  arrange(desc(number_of_episodes) )
```

### Round_date()

An alternative would be to use `Lubridate`'s `round_date()` function, which let's us round date-time objects to their nearest year, month, week, day, etc. It works like this:

```{r}
rebels_rounded_cols <- rebels_cl |> 
  mutate(year = round_date(air_date_fixed, "year")) |>
  mutate(month = round_date(air_date_fixed, "month")) |>
  mutate(week = round_date(air_date_fixed, "week")) |>
  mutate(day = round_date(air_date_fixed, "day"))

rebels_rounded_cols |> select(episode_title, year, month, week, day) |> glimpse()
```

Rounding the dates to their nearest year/month/week/day/etc can be helpful later on, for example when visualizing the data. Instead of round to the nearest values, we can use `floor_date()` to round down or `ceiling_date()` to round up.

### The yday() function

What if we wanted to identify the earliest, each year, that an episode aired? For that purpose, we could use the `yday()` (year day) function, which simply tells us how many days into a year a given date is. My son and I share the same birthday (February 5). That's the 36th day of the year:

```{r}
yday("2022-02-05")
```

To find the earliest episode airdate for each year, we could do this:

```{r}
rebels_cl |>
  mutate(
    dy = yday(air_date_fixed)
    ) |> 
  group_by(year) |> 
  slice_min(air_date_fixed) |> 
  ungroup() |>
  select(episode_title, season, air_date_fixed, year, dy)
```

This shows the first-aired episode for each of the years from 2014â€“2018. Notice the few doppelgÃ¤ngers? It looks liek seasons 3 and 4 started each started with a double episode.

There are few things going on in the chunk above. Here's a quick recap of what each line does:

* We start with our object, `rebels_cl`, and then ...
* We use `mutate()` to create a new column called `dy` ...
* To get the `dy` column to specify each dates number within a year, we use `yday()`, and then ...
* We `group_by()` because we want the earliest episode within each year, and then ...
* We use `slice_min()` to get just the earliest episode within each year. (Otherwise, we our output would all the episodes.) And then ...
* We use `ungroup()` to remove the grouped `dy` column. Not essential here but might be handy if you need to perform additional operations. And then ...
* `select()` let's us show just a few columns to make the output more readable at a glance.

## The end

That's it for now, young Padawan! Good luck on your quest, stay safe, and may the force be with you! ðŸ’ª
